<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>Povi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root { --orange:#ff8a00; --pink:#ff9acb; --blue:#19b5fe; --divider:#111; --text:#222; --muted:#888; --bg:#fafbfc; }
      *{box-sizing:border-box}
      body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple SD Gothic Neo","Noto Sans KR",sans-serif;background:var(--bg);color:var(--text)}
      .page{display:grid;grid-template-columns:1fr 6px 1.2fr;gap:0;min-height:100vh}
      .divider{background:var(--divider);width:6px;height:100%}
      .left,.right{padding:24px}
      .panel{background:#fff;border:4px solid var(--orange);border-radius:16px;padding:18px}
      .panel h2{margin:0 0 12px;color:var(--orange);font-weight:800;font-size:20px}
      .panel small.hint{color:var(--muted);display:block;margin-top:10px}
      .panel-pink{background:#fff;border:4px solid var(--pink);border-radius:16px;padding:18px;margin-top:24px;min-height:260px;display:flex;flex-direction:column}
      .panel-pink h2{margin:0 0 12px;color:var(--pink);font-weight:800;font-size:20px}
      .ko-box{flex:1;border:2px dashed #bbb;border-radius:12px;color:#d45a9e;padding:16px;line-height:1.6;white-space:pre-wrap}
      .controls{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:8px}
      .controls2{display:grid;grid-template-columns:1.1fr 1fr 1fr;gap:8px;margin-top:8px}
      input[type="file"]{display:block;width:100%;padding:10px 12px;border-radius:12px;background:#111;color:#fff;border:0;font-weight:700}
      .btn{display:inline-flex;justify-content:center;align-items:center;width:100%;padding:10px 12px;border-radius:12px;font-weight:800;border:0;cursor:pointer;transition:transform .03s ease, opacity .2s}
      .btn:active{transform:translateY(1px)}
      .btn-primary{background:#111;color:#fff}
      .btn-secondary{background:#666;color:#fff}
      .btn-ghost{background:#eee;color:#333}
      .btn:disabled{opacity:.45;cursor:not-allowed}
      .wave-box{display:none;margin-top:8px;border-radius:12px;overflow:hidden;background:#111;border:1px dashed #333}
      .audio-box{margin-top:10px;background:#fafafa;border:1px dashed #ccc;border-radius:12px;padding:10px;display:none}
      .image-panel{background:#fff;border:6px solid var(--blue);border-radius:16px;padding:18px;min-height:calc(100vh - 48px);display:flex;flex-direction:column}
      .image-panel h2{margin:0 0 8px;color:#1aa3e0;font-size:20px;font-weight:800}
      .image-wrap{flex:1;display:grid;place-items:center;border-radius:12px;background:#f5fbff;overflow:hidden}
      .image-wrap img{max-width:100%;height:auto;display:block}
      .prompt-debug{margin-top:10px;padding:10px;background:#f2f5f8;border-radius:12px;color:#334;font-size:12px;white-space:pre-wrap;display:none}
      @media (max-width:980px){.page{grid-template-columns:1fr}.divider{display:none}.controls{grid-template-columns:repeat(2,1fr)}.controls2{grid-template-columns:1fr 1fr}.image-panel{min-height:auto;margin-top:18px}}
    </style>
  </head>
  <body>
    <div class="page">
      <div class="left">
        <section class="panel">
          <h2>녹음 / 업로드 / 미리 듣기</h2>

          <!-- Row 1: 녹음 제어 -->
          <div class="controls">
            <button id="btnRec" class="btn btn-primary">● 녹음 시작</button>
            <button id="btnStop" class="btn btn-secondary" disabled>■ 녹음 정지</button>
            <button id="btnPreview" class="btn btn-ghost" disabled>▶ 미리 듣기</button>
            <button id="btnAnalyze" class="btn btn-ghost" disabled>분석하기</button>
          </div>
          <small id="recStatus" style="margin-left:2px;color:#777">대기 중</small>

          <!-- Row 2: 업로드(파일 선택만) -->
          <div class="controls2">
            <input type="file" id="file" accept="audio/*" />
            <div></div><div></div>
          </div>

          <!-- Waveform canvas (녹음 중에만 표시) -->
          <div class="wave-box" id="waveBox">
            <canvas id="waveform" height="120" style="width:100%;height:120px;display:block"></canvas>
          </div>

          <div class="audio-box" id="audioBox">
            <audio id="player" controls style="width:100%"></audio>
          </div>
          <small class="hint">필요하면 미리 듣기 후 분석하기를 눌러 주세요.</small>
        </section>

        <section class="panel-pink">
          <h2>분석 후 설명</h2>
          <div id="koBox" class="ko-box">분석 결과가 여기에 표시됩니다.</div>
          <div class="controls" style="grid-template-columns:1fr; margin-top:12px">
            <button id="btnToImage" class="btn btn-primary" disabled>이미지 생성</button>
          </div>
        </section>
      </div>

      <div class="divider"></div>

      <div class="right">
        <section class="image-panel">
          <h2>이미지 결과</h2>
          <div class="image-wrap" id="imageWrap">
            <span style="color:#8ad2ff">아직 생성된 이미지가 없습니다</span>
          </div>
          <div id="promptDebug" class="prompt-debug"></div>
        </section>
      </div>
    </div>

<script>
  const API_BASE = "";

  function normalizeArray(val){
    if(Array.isArray(val)) return val;
    if(val == null) return [];
    if(typeof val === "string"){
      try{ return normalizeArray(JSON.parse(val)); }catch{}
      return val.split(/[,\s]+/).map(s=>s.trim()).filter(Boolean);
    }
    if(typeof val === "object"){
      const out=[]; for(const k in val){ const v=val[k];
        if(Array.isArray(v)) out.push(...v.map(String));
        else if(v!=null) out.push(String(v));
      } return out;
    }
    return [String(val)];
  }
  function normalizeResult(raw){
    const payload = raw?.result || raw?.data || raw || {};
    const en_prompt = payload.en_prompt ?? payload.enPrompt ?? payload.prompt_en ?? payload.prompt ?? "";
    const negative_prompt = payload.negative_prompt ?? payload.negativePrompt ?? payload.negative ?? "";
    return {
      ok: raw?.ok ?? true,
      description: payload.description ?? "",
      ko_explanation: payload.ko_explanation ?? payload.koExplanation ?? payload.description ?? "",
      en_prompt, negative_prompt,
      style_tags: normalizeArray(payload.style_tags ?? payload.styleTags ?? payload.tags ?? payload.tag ?? payload.keywords),
      palette: normalizeArray(payload.palette),
      seed_idea: payload.seed_idea ?? payload.seedIdea ?? payload.seed ?? "",
      features: payload.features ?? null,
    };
  }

  let mediaRecorder, chunks=[];
  let currentBlob=null, lastBlobUrl=null, fileBlobUrl=null;
  let lastResult=null;

  // Waveform globals
  let audioCtx, analyser, sourceNode, dataArray, animationId;
  const waveformCanvas = document.getElementById("waveform");
  const waveBox = document.getElementById("waveBox");
  const canvasCtx = waveformCanvas.getContext("2d");

  const btnRec=document.getElementById("btnRec");
  const btnStop=document.getElementById("btnStop");
  const btnPreview=document.getElementById("btnPreview");
  const btnAnalyze=document.getElementById("btnAnalyze");
  const player=document.getElementById("player");
  const audioBox=document.getElementById("audioBox");
  const fileInput=document.getElementById("file");

  function setStatus(msg){ document.getElementById("recStatus").textContent = msg; }
  function showImage(url){
    const wrap=document.getElementById("imageWrap");
    wrap.innerHTML=""; const img=document.createElement("img"); img.src=url; img.alt="result"; wrap.appendChild(img);
  }
  function hideDebug(){ const box=document.getElementById("promptDebug"); box.style.display="none"; box.textContent=""; }

  function cleanText(txt) {
    if (!txt) return "";
    let out = txt;
    out = out.replace(/\b(negative|prompt|style|tag|palette|seed|cheeky|cartoon|outline|colors?)\b/gi, "");
    out = out.replace(/\[[^\]]*\]|\([^\)]*\)|\b[A-Za-z#0-9\-\_]{2,}\b/g, "");
    out = out.replace(/\s{2,}/g, " ").trim();
    return out;
  }

  function fillUI(n){
    const ko=cleanText(n.ko_explanation || n.description);
    document.getElementById("koBox").textContent = ko || "설명을 생성하지 못했습니다.";
    hideDebug();
    document.getElementById("btnToImage").disabled = !n.en_prompt;
  }

  function updateActionButtons(){
    const hasRecord = !!currentBlob;
    const hasFile = !!(fileInput.files && fileInput.files[0]);
    const enabled = hasRecord || hasFile;
    btnPreview.disabled = !enabled;
    btnAnalyze.disabled = !enabled;
  }

  function getPreviewSource(){
    if(currentBlob) return { type:"record", blob: currentBlob };
    const f = fileInput.files?.[0];
    if(f) return { type:"file", file: f };
    return null;
  }

  async function analyzeCurrent(){
    const src = getPreviewSource();
    if(!src){ alert("녹음하거나 파일을 선택하세요."); return; }
    const fd = new FormData();
    if(src.type === "record"){
      fd.append("file", new File([src.blob], "record.webm", {type:"audio/webm"}));
    } else {
      fd.append("file", src.file);
    }
    setStatus("분석 중…");
    const r=await fetch(`${API_BASE}/analyze_api`,{method:"POST",body:fd});
    const raw=await r.json().catch(()=>null);
    if(!raw || raw.ok===false){ alert(raw?.error || "분석 실패"); setStatus("대기 중"); return; }
    const data=normalizeResult(raw); lastResult=data; fillUI(data); setStatus("대기 중");
  }

  // ===== Waveform drawing =====
  function startWaveform(stream){
    waveBox.style.display = "block";
    // Resize canvas to actual CSS width
    waveformCanvas.width = waveformCanvas.clientWidth;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    sourceNode = audioCtx.createMediaStreamSource(stream);
    sourceNode.connect(analyser);

    analyser.fftSize = 2048;
    const bufferLength = analyser.fftSize;
    dataArray = new Uint8Array(bufferLength);

    function draw(){
      animationId = requestAnimationFrame(draw);
      analyser.getByteTimeDomainData(dataArray);

      canvasCtx.fillStyle = "#111";
      canvasCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);

      canvasCtx.lineWidth = 2;
      canvasCtx.strokeStyle = "#ff8a00";
      canvasCtx.beginPath();

      const sliceWidth = waveformCanvas.width / bufferLength;
      let x = 0;
      for(let i=0;i<bufferLength;i++){
        const v = dataArray[i] / 128.0;
        const y = (v * waveformCanvas.height/2);
        if(i===0) canvasCtx.moveTo(x, y);
        else canvasCtx.lineTo(x, y);
        x += sliceWidth;
      }
      canvasCtx.lineTo(waveformCanvas.width, waveformCanvas.height/2);
      canvasCtx.stroke();
    }
    draw();
  }

  function stopWaveform(){
    if(animationId) cancelAnimationFrame(animationId);
    if(audioCtx){ audioCtx.close(); audioCtx = null; }
    waveBox.style.display = "none";
    // clear canvas
    canvasCtx.clearRect(0,0,waveformCanvas.width,waveformCanvas.height);
  }

  // ===== Recording / UI events =====
  btnRec.onclick=async ()=>{
    const stream=await navigator.mediaDevices.getUserMedia({audio:true});
    startWaveform(stream);   // start drawing
    chunks=[]; currentBlob=null; if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
    mediaRecorder=new MediaRecorder(stream,{mimeType:"audio/webm"});
    mediaRecorder.ondataavailable=(e)=>{ if(e.data.size) chunks.push(e.data); };
    mediaRecorder.onstop=()=>{
      currentBlob=new Blob(chunks,{type:"audio/webm"});
      // stop waveform when recorder stops
      stopWaveform();
      setStatus("녹음 완료 — 미리 듣기 가능");
      btnStop.disabled=true;
      updateActionButtons();
    };
    mediaRecorder.start();
    setStatus("녹음 중…");
    btnStop.disabled=false;
    updateActionButtons();
  };

  btnStop.onclick=()=>{
    if(mediaRecorder && mediaRecorder.state!=="inactive"){
      mediaRecorder.stop();
    }
  };

  btnPreview.onclick=()=>{
    const src = getPreviewSource();
    if(!src){ alert("녹음하거나 파일을 선택하세요."); return; }
    if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
    if(src.type === "record"){
      lastBlobUrl = URL.createObjectURL(src.blob);
    } else {
      if(fileBlobUrl) URL.revokeObjectURL(fileBlobUrl);
      fileBlobUrl = URL.createObjectURL(src.file);
      lastBlobUrl = fileBlobUrl;
    }
    player.src = lastBlobUrl;
    audioBox.style.display = "block"; // show player only when previewing
    player.play().catch(()=>{});
  };

  btnAnalyze.onclick=analyzeCurrent;

  fileInput.addEventListener("change",()=>{
    const f=fileInput.files?.[0];
    if(f){ currentBlob=null; } // prefer uploaded file when exists
    updateActionButtons();
  });

  document.getElementById("btnToImage").onclick=async ()=>{
    if(!lastResult?.en_prompt){ alert("먼저 분석을 완료하세요."); return; }
    const r=await fetch(`${API_BASE}/image/render`,{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({ prompt:lastResult.en_prompt, negativePrompt:lastResult.negative_prompt, width:768, height:768 }),
    });
    if(!r.ok){ const msg=await r.text().catch(()=> ""); alert(`Image API ${r.status}\n${msg||"Request failed"}`); return; }
    const j=await r.json().catch(()=>null);
    if(!j?.imageUrl){ alert(j?.error || "imageUrl이 응답에 없습니다."); return; }
    showImage(j.imageUrl);
  };

// ===== Enhancements: codec fallback, audio context resume, robust preview =====
let gStream = null;

// pick best mimeType
function pickMime(){
  const candidates = [
    "audio/webm;codecs=opus",
    "audio/webm",
    "audio/mp4",
    "audio/ogg;codecs=opus"
  ];
  for (const m of candidates){
    try { if (MediaRecorder.isTypeSupported(m)) return m; } catch {}
  }
  return "";
}

// ensure audio context is running (some browsers start suspended)
async function ensureCtx(){
  try {
    if (audioCtx && audioCtx.state === "suspended") {
      await audioCtx.resume();
    }
  } catch(e){/*noop*/}
}
document.addEventListener("visibilitychange", ensureCtx);

// robust play helper
async function safePlay(el){
  try{
    el.volume = 1;
    el.muted = false;
    el.pause();
    el.load();
    await el.play();
  }catch(e){
    // show a friendly hint
    console.warn("Autoplay prevented or play failed:", e);
    setStatus("재생 버튼(▶)을 누르거나 시스템 볼륨/출력 장치를 확인하세요.");
  }
}

// Resize canvas to container width
(function(){
  const ro = new ResizeObserver(()=>{
    const w = waveformCanvas.clientWidth || 600;
    waveformCanvas.width = w;
  });
  ro.observe(waveformCanvas);
})();

// override record handlers to keep the gStream and use codec fallback
btnRec.onclick = async ()=>{
  const stream=await navigator.mediaDevices.getUserMedia({audio:true});
  gStream = stream;
  await ensureCtx();
  startWaveform(stream);
  chunks=[]; currentBlob=null; if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
  const mime = pickMime();
  try{
    mediaRecorder=new MediaRecorder(stream, mime ? {mimeType: mime} : undefined);
  }catch(e){
    mediaRecorder=new MediaRecorder(stream);
  }
  mediaRecorder.ondataavailable=(e)=>{ if(e.data.size) chunks.push(e.data); };
  mediaRecorder.onstop=()=>{
    const blobType = mime || "audio/webm";
    currentBlob=new Blob(chunks,{type: blobType});
    stopWaveform();
    setStatus("녹음 완료 — 미리 듣기 가능");
    btnStop.disabled=true;
    updateActionButtons();
    // stop input tracks after capture
    try{ gStream.getTracks().forEach(t=>t.stop()); }catch{}
    gStream = null;
  };
  mediaRecorder.start();
  setStatus("녹음 중…");
  btnStop.disabled=false;
  updateActionButtons();
};

btnPreview.onclick=()=>{
  const src = getPreviewSource();
  if(!src){ alert("녹음하거나 파일을 선택하세요."); return; }
  if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
  if(src.type === "record"){
    lastBlobUrl = URL.createObjectURL(src.blob);
  } else {
    if(fileBlobUrl) URL.revokeObjectURL(fileBlobUrl);
    fileBlobUrl = URL.createObjectURL(src.file);
    lastBlobUrl = fileBlobUrl;
  }
  player.src = lastBlobUrl;
  audioBox.style.display = "block";
  safePlay(player);
};
</script>
  </body>
</html>
